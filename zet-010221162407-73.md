---
created: 2021-02-01 16:24
title: TCP
tags:
backlinks: [index](index.md)
type: text/x-markdown
description:
---

数据在 TCP 层叫 **Stream**，数据分组叫 **分段 (Segment)**。IP 层为 **Datagram**，分组叫**分片 (Fragment)**， **UDP** 中分组为 **Message** 。

[Segment](zet-010221230620-75.md)（数据段）

Segment 包只有 source Port 和 Destination Port(IP 在网络层）。

![Segment 结构图](https://raw.githubusercontent.com/e1nfalda/IAaFaJdFLzSk/ignore/uPic/134217wuckuyvvcsuygnds.png)

* Sequence Number: 序列号；解决乱序问题。

* Acknowledgement Number: ACK。用来确认收到。  [黄色字段 ACK 会传递的字段图](https://raw.githubusercontent.com/e1nfalda/IAaFaJdFLzSk/ignore/uPic/image-20200925172720046.png)

* Window(Advertised-Window): 滑动窗口。流量控制。

* TCP Flag: 包的类型。SYN,FIN,ACK…[详细](https://raw.githubusercontent.com/e1nfalda/IAaFaJdFLzSk/ignore/uPic/image-20190725155505155.png)

## TCP 状态机

![tcpfsm 图](https://raw.githubusercontent.com/e1nfalda/IAaFaJdFLzSk/ignore/uPic/tcpfsm.png)

* **SYN 超时**：server 收到 SYN 返回 SYN-ACK 后，等待 client 发送 SYN 状态时，发送 $2^n$(0-4) 秒间隔五次后未收到响应。
* **SYN FLOOD 攻击：** 因为需要 63（1+2+…16）秒所以利用该点，无线发送 SYN 请求。
* **ISN（初始化序列号）:**  未避免序号出现重复。系统有模拟时钟，每 4 微秒 +1 操作，$2^{32}$ 秒归 0。
* **MSL(maxium segment lifecycle)**: 当小于 $2^{32}$ 秒时就不会出现重复序号。

## TCP 重传机制

两种情况会出发重传：`dupACK`和`RTO`.

### DupAck 重传

* **快速重传 (fast retransmit)**：sender 收到相同包三次 ack，直接重传。

* **SACK(selective Acknowlegement)** 因未包到达无顺序，ACK 中带上后 SN 后已经收到的。

  > **D-SACK（Duplicate SACK）**
  >
  > 意义：使 sender 知道如下：
  >
  > > 1. 知道是不是丢包。
  > > 2. 检查 timeout 时间是否过小。
  > > 3. 包被网络复制。
  > > 4. 网络出现`reordering`。

### 超时重传 （timeout retransmit）

  `RTT(Round Trip Time)` 发出的时间计时 t0，接收到 ACK 计时 t1；rtt=t1-t0。

  `RTO(Retransmission Time Out)` 冲出

加权移动算法（经典，Jacobson / Karels 算法 常用）

> RTO 计算算法：
>
> * 1）首先，先采样 RTT，记下最近好几次的 RTT 值。
> * 2）然后做平滑计算`SRTT`（ Smoothed RTT），公式为：（其中的 α 取值在 0.8 到 0.9 之间，这个算法英文叫 Exponential weighted moving average，中文叫：加权移动平均）
>   SRTT = ( α * SRTT ) + ((1* α) * RTT)
> * 3）开始计算 RTO。公式如下：
>   RTO = min [ UBOUND,  max [ LBOUND,   (β * SRTT) ]  ]
> 1. **UBOUND** 是最大的 timeout 时间，上限值
> 2. **LBOUND** 是最小的 timeout 时间，下限值
>
> β 值一般在 1.3 到 2.0 之间。
>
> #### Karn / Partridge 算法：
>
> ​    忽略重传。
>
> #### jacobson/karels 算法：
>
> * SRTT = SRTT + α (RTT – SRTT) ：计算平滑 RTT；
> * DevRTT = (1-β)*DevRTT + β*(|RTT-SRTT|) ：计算平滑 RTT 和真实的差距（加权移动平均）；
> * RTO= μ * SRTT + ∂ *DevRTT ： 神一样的公式。
>
> （其中：在 Linux 下，α = 0.125，β = 0.25， μ = 1，∂ = 4）参数未调教出来的。

### 拥堵控制（congestion control）

**congestion window（cwnd）**

> 类似 slidewindow。区别：由 sender 维护。通过控制 cwnd 控制流量发送快慢。

**控制的四个阶段的算法**

1. 慢启动（slow start）。最初状态
2. 拥塞避免（congestion avoidance）。当 cwnd >= ssthresh（slow start threshod）时，进入该状态。
3. 拥塞发生（fast retransmit）。当出现 RTO 超时，sshthresh=cwnd/2 进入慢启动过程。`fast retransmit`重复 3 个 ACK 时，进入 Fast-Recovery 算法。
4. 快速恢复。

> 四个算法通过是否丢包、是否超时判断在哪个阶段，进而选择响应的算法。

### 流量控制（flow control）

> **ACK** 一般当 receiver 收到两个包后发送 ACk。主要包含：
>
> 1. 期待要收到下一个数据包的编号。
> 2. 接收方的接收窗口的剩余容量

**slide window(advertised window,rwnd)**

> receiver 维护。
>
> 作用：流量控制手段之一。TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

**zero window：**receiver 通知 sender，自己窗口为 0，停止发送。`ZWP(Zero Window Probe)`：sender 30-60 秒间隔发送三次确认，如果依然 zero window，则断开链接。

> **只要有等待的地方都可能出现 DDoS 攻击**，Zero Window 也不例外，一些攻击者会在和 HTTP 建好链发完 GET 请求后，就把 Window 设置为 0，然后服务端就只能等待进行 ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。

**silly window syndrome**: 窗口糊涂综合征。reveiver 处理不及 sender 快，导致 window size 越来越小，发送的包也越来越小。

> 解决算法：[Nagle’s algorithm](http://en.wikipedia.org/wiki/Nagle's_algorithm)。

## 网络帧：

### 协议格式：SRC_ADDR | DESC_ADDR | CONTENT_PROTOCOL | CONTENT

>  每个硬件和硬件的传播叫 hop，链路层的一次传播为 1hop，一次网络层传输可能有多个 hop 传输。

---

[维基百科 -TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Window_scaling)

[tcp in a nutshell](http://www.cs.miami.edu/home/burt/learning/Csc524.032/notes/tcp_nutshell.html)

[深入理解 TCP 协议（上）：理论基础](http://www.52im.net/thread-513-1-1.html)
[深入理解 TCP 协议（下）：理论基础](http://www.52im.net/thread-515-1-1.html)

[阮一峰：TCP 协议简介](http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html)

